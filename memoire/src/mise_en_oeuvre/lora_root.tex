\section{Racine LoRa}\label{sec:work-lora-root}
\renewcommand{\rightmark}{Trames LoRaMac}

    Le RN2483 est interfacé à l'ordinateur de développement via un bridge USB-UART.

    L'implémentation se présente sous forme d'un package python qui donne accès à une variable 
    \texttt{NETWORK\_STACK} qui fait référence à une instance de la classe \texttt{NetworkStack} et permet d'accèder aux trois 
    différentes couches, l'adresse LoRaMAC du noeud, son adresse IPv6 issue de la conversion de son 
    adresse LoRaMAC ainsi que trois fonctions: \texttt{init}, \texttt{send} et \texttt{register\_listener} qui sont des 
    fonctions de l'interface IP et permettent respectivement d'initialiser la pile réseau, 
    d'envoyer des paquets IPv6 et d'enregister une fonction callback qui sera appelée lorsqu'un 
    paquet IPv6 reçu est disponible. L'usage et l'implémentation de ses fonctions sont détaillées 
    dans la description de la \nameref{subsec:work-loraroot:iplayer}.

\subsection*{Couche physique}
    La couche physique définit le format des adresses et trames LoRaMAC, ainsi que que le driver 
    permettant de simplifier l'utilisation du RN2483 par l'abstraction des communications UART.

    Les classes \texttt{LoraAddr} et \texttt{LoraFrame} définissent respectivement les adresses 
    LoRaMAC et les trames LoRaMAC conformément à leur définition établie dans le chapitre ~\ref
    {chap:archi}. Ces deux classes possèdent les fonctions nécessaires pour les sérialiser (resp.
    désérialiser) en (resp. depuis) une chaine de caractères hexadecimal qui est le format de donnée demandé par le RN2483.

    Le driver du RN2483 est implémenté par la classe \texttt{LoraPhy}. Elle possède deux Threads servant à la réception et à l'envoi des trames UART. Le Thread d'envoi récupère les trames 
    dans un buffer qui est une \texttt{Queue} FIFO de la librairie python \texttt{queue}.
    Une fois qu'une trame UART a été envoyée, il est bloqué par une variable conditionelle jusqu'au moment où le Thread de réception lui signale qu'une réponse attendue en retour de la trame envoyée a été reçue.

    Quand le Thread de réception reçoit une trame UART contenant une trame LoRaMAC, celui-ci l'ajoute dans un buffer de réception qui sera lu par la couche MAC.

    Les fonctions publiques du driver sont les suivantes:
    \begin{itemize}
        \item \texttt{init()}: Initialise la connexion série en utilisant librairie python \textit{pyserial} (version 3.4) et démarre les Threads.
        \item \texttt{phy\_send(loraFrame: LoraFrame)}: Permet d'envoyer une trame LoRaMAC
        \item \texttt{phy\_timeout(timeout: int)}: Permet de définir le temps d'expiration du watchdog timer qui est activé pour chaque transmission ou réception. Pour le désactiver, la valeur qui doit être utilisée est zéro.
        \item \texttt{phy\_rx()}: Permet de mettre le RN2483 en mode réception
        \item \texttt{getFrame()}: Permet d'obtenir la prochaine trame du biffer de réception. Si le buffer est vide, la fonction est bloquante.
    \end{itemize}

    Mise à part la fonction \texttt{getFrame()}, toutes les autres fonctions publiques alimentent le buffer d'envoi avec la trame UART appropriée.

\subsection*{Couche MAC}

\subsection*{Couche IP}\label{subsec:work-loraroot:iplayer}