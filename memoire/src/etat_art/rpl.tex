\newpage
\section{RPL}\label{sec:state-rpl}
\renewcommand{\rightmark}{RPL}
%TODO tour des protocoles de routages ??

Routing Protocol for Low-Power and Lossy Networks~\cite{rfc:rpl} est un protocole de routage IPv6 destiné aux réseaux dont les noeuds sont contraints en énergie et dont les liens sont soumis à des pertes importantes de paquets (Low-power and Lossy Networks, LLNs).
Ce protocole à vecteur de distance est un protocole proactif, c'est à dire que les routes sont établies avant qu'elles ne soient nécessaires.

RPL sépare le traitement et la transmission des paquets de contrôle de l'optimisation de l'objectif de routage. Cela permet de l'adapter à un large éventail d'applications des LLNs comme la domotique, l'automatisation industriel ou encore la récolte de données.


\subsection*{Topologie}
    RPL construit un DODAG (Destination Oriented Directed Acyclic Graph). Un DODAG est un graphe   dirigé acyclique (DAG) ayant une seule racine (Fig.~\ref{fig:state-dodag}). De par cette architecture RPL est adapté aux applications de collecte de données ce qui est le principale objectif de ce projet. En effet, la route d'un noeud à la racine est facilement établie car tous les noeuds du chemins envoient les données à leur parent.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{res/pictures/dodag.drawio.png}
        \caption{DODAG.}
        \label{fig:state-dodag}
    \end{figure}


\subsection*{Fonctions objectif}
Une fonction objectif (OF) définit comment plusieurs métriques sont utilisées pour calculer le rang d'un noeud. Celui-ci détermine la position du noeud dans le DODAG par rapport aux autres noeuds.
Le rang augmente strictement dans le sens descendant et diminue strictement dans le sens montant. Ainsi, pour un noeud $n$, $rang(n)>rang(parent(n))$. La figure~\ref{fig:state-dodag} illustre un DODAG avec des valeurs de rang fictives attribuées aux noeuds. Sur cet exemple, la racine du DODAG a comme rang, la valeur par défaut $\textsc{root\_rank}=1$ définie dans le RFC.

Cette section décrit brièvement les fonction objetif OF0 et MRHOF, sur base du RFC 6552~\cite{rfc:of0} et du RFC 6719 ~\cite{rfc:mrhof}, qui sont implémentées dans Contiki.

    \subsubsection*{OF0}
        \textit{Objective Function Zero} est une fonction dont l'objectif est de choisir un parent qui permettra à un noeud d'avoir la racine du DODAG le plus proche possible.
        Le calcul du rang d'un noeud $N$, $R(N)$, est décrit par l'équation~\ref{eq:state-rankOF0}. Il est calculé pour chaque parent potentiel. Le parent préféré choisi sera alors le parent potentiel qui implique le plus petit $R(N)$.\par


        Le calcul du rang commence par le calcul de la variable \textit{step\_of\_rank} ($Sp$) qui est 
        basée sur  les propriétés et métriques du lien avec le parent potentiel. Le RFC 
        recommande de baser ce calcul sur des propriétés dynamiques comme la métrique \textit{expected transmission count (ETX)} décrit dans l'article de Couto, Aguayo, Bicket et Morris
        ~\cite{paper:etx} qui est une métrique qui permet de minimiser le nombre de transmissions requises pour transmettre un paquet.
        car utiliser des propriétés statiques, comme un coût administratif, revient à avoir un
        rang analogue au nombre de sauts. $Sp$ est mutlipliée par la variable \textit{rank\_factor} ($Rf$) qui est utilisée pour multiplier son effet dans le calcul de
        \textit{rank\_increase}. $Rf$ doit être un entier strictement positif et sa valeur par défaut est 1.

        $Sr$ est un terme plus petit ou égal à la variable \textit{stretch\_of\_rank} qui est l'augmentation maximum de \textit{step\_of\_rank} avec le parent.


        La variable \textit{rank\_increase} est multipliée par le facteur \textit{MinHopRankIncrease} qui est défini par le RFC 6550~\cite{rfc:rpl} comme l'augmentation minimum du rang entre un noeud et n'importe lequel de ses parents. Sa valeur par défaut est \textsl{\textsc{default\_min\_hop\_rank\_increase}} qui a une valeur de 256.
        
        La variable $R(P)$ est le rang d'un parent $P$.

        \begin{equation}\label{eq:state-rankOF0}
            \begin{aligned}
                rank\_increase &= (Rf * Sp + Sr) * MinHopRankIncrease\\
                R(N) &= R(P) + rank\_increase    
            \end{aligned}
        \end{equation} 
        %Le rang d'un noeud $R(N)$ est calculé comme suit:
        %    \[rank\_increase = (Rf * Sp + Sr) * MinHopRankIncrease\]
        %    \[R(N) = R(P) + rank\_increase\]
        %    où
        %    \begin{itemize}
        %        \item $Rf$ est le $rank\_factor$ et $Sr \leq stretch\_of\_rank$ avec %$rank\_factor$ et $stretch\_of\_rank$ deux paramètres de la fonction
        %        
        %        \item $Sp$ est le $step\_of\_rank$ qui est une valeur basée sur les propriétés %du lien. 
        %        
        %        \item $MinHopRankIncrease$ est une constante
        %        
        %        \item $R(P)$ est le rang d'un parent $p$
        %    \end{itemize}
        %    $R(N)$ est calculé pour chaque parent potentiel. Le parent préféré choisi sera %alors le parent potentiel qui implique le plus petit $R(N)$.
                
    \subsubsection*{MRHOF}%rfc6719
            \textit{Minimum Rank with Hysteresis Objective Function} est une fonction dont l'objectif est de sélectionner les routes qui minimisent une métrique additive en utilisant l'hystérésis
            pour réduire les changements de parents en réponse a de petites variations de la métrique.
            
            Pour cela, un noeud va calculer le coût des chemins avec chaque candidat parent. Ce coût sera la somme de deux éléments:
            \begin{itemize}
                \item La valeur de la métrique utilisée contenue dans les DIOs d'un candidat parent
                \item La valeur de la métrique pour le lien entre ce noeud et le candidat parent
            \end{itemize}
            Si le coût d'un chemin est plus grand qu'une constante \textsl{\textsc{max\_link\_metric}} dont la valeur recommandée par le RFC 6719~\cite{rfc:mrhof} est 512,
            le noeud va exclure le candidat parent utilisant ce lien.
            Un noeud va choisir comme parent le candidat parent pour lequel le coût du chemin est le plus petit. Le changement de parent ne s'effectue que si 
            \[ |cost-old\_cost| > \textsc{parent\_switch\_treshold} \]
            Le RFC 6719 recommande 192 comme valeur pour \textsl{\textsc{parent\_switch\_treshold}} si la métrique utilisée est ETX.

\subsection*{Messages RPL}

\subsubsection*{DIO}
    Les DIOs (DODAG Information Object) annoncent des informations sur le DODAG qui permettent aux noeuds de découvrir une instant RPL, de sélectionner un parent ou encore de maintenir le DODAG.
    Un DIO, illustré à la figure~\ref{fig:state-dio}, inclu notemment les champs suivants:
    \begin{itemize}
        \item InstanceID: Identifie l'instance RPL du DODAG
        \item Rank: Le rang du noeud qui émet le DIO
        \item MOP (Mode of Operation): Le mode d'opération de l'instance RPL (c.f. \fullref{subsec:state-mop}).
        \begin{enumerate}
            \setcounter{enumi}{-1}
            \item Pas de routes descendantes
            \item Non-storing mode
            \item Storing mode sans multicast
            \item Storing mode avec multicast
        \end{enumerate}
        \item DODAGID: Adresse IPv6 définie par la racine qui identifie le DODAG
    \end{itemize}
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.5]{res/pictures/dio.drawio.png}
        \caption{DODAG Information Object.}
        \label{fig:state-dio}
    \end{figure}

    Les DIOs sont transmis en utilisant l'algorithme Trickle définis dans~\cite{rfc:trickle}.

\subsubsection*{DIS}
    Les DODAG Information Solocitation (DIS) sont utilisés pour solicité un DIO d'un noeud RPL.

\subsubsection*{DAO}%p42
    Les DAOs (Destination Advertisement Object) sont utilisés pour établir les routes descendantes.
    Ils sont donc envoyés vers le haut du DODAG. Le format du DAO est illustré à la figure~\ref{fig:state-dao}. Un DAO est composé des champs suivants:
    \begin{itemize}
        \item InstanceID: identifie l'instance du DODAG
        \item K: indique que le destinataire doit répondre avec un DAO-ACK
        \item D: indique que le DODAGID est présent
        \item DAOSequence: Incrémenté à chaque DAO d'un noeud et répété dans le DAO-ACK
        \item DODAGID (optionnel)
    \end{itemize}
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.5]{res/pictures/dao.drawio.png}
        \caption{DODAG Information Object.}
        \label{fig:state-dao}
    \end{figure}

\subsubsection*{DAO-ACK}
    Le format d'un DAO-ACK est similaire à celui d'un DAO. Il n'est donc pas utile de le décrire.

\subsection*{Construction du réseau}
    La construction d'un DODAG est réalisée via l'échange de messages DIOs pour les routes montantes et de DAOs pour les routes descendantes. La figure~\ref{fig:state-dio-dao} illustre l'échange de ces messages.

\subsubsection*{Routes Montantes}
    %rfc: p 16, 19, 66
    Les routes montantes sont construites et maintenues avec les DIOs.
    L'algorithme de construction de DODAG est le suivant:
    \begin{enumerate}
        \item Les noeuds étant configurés comme racine d'un DODAG diffusent des DIOs en mutlicast à tous les noeuds RPL
        \item Les noeuds voulant rejoindre un DODAG écoutent ces DIOs et utilisent leurs informations pour rejoindre le DODAG (i.e. sélectionner un parent) ou maintenir le DODAG existant en accord avec la fonction objectif
        \item Les noeuds rajoutes des entrée dans leur table de routage pour les destinations spécifiées dans le DIO via leurs parents.
    \end{enumerate}

    Si une adresse de destination n'appartient pas au DODAG, la racine du DODAG peu transférer les paquets à l'exterieur de ce réseau, ou, si elle n'en est pas capable, les ignorer.     

\subsubsection*{Routes Descendantes}
    %rfc: p 19
    Les routes descendantes sont construites et maintenues avec les DAOS.
    L'échange des DAOs différe selon le mode de fonctionnement (MOP) du réseau. Ces différences sont détaillées en \fullref{subsec:state-mop}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{res/pictures/dao-dio.drawio.png}
    \caption{Propagation des DIOs et DAOs.}
    \label{fig:state-dio-dao}
\end{figure}

%\subsection{Maintenance du réseau}


\subsection*{Modes de fonctionnements}\label{subsec:state-mop}
    %RFC p 19,20,41,77,78
    Le mode de fonctionnement d'une instance RPL, est défini administrativement et est annoncé par la racine. Les modes suivants sont disponibles:
    \begin{itemize}
        \item \textbf{Pas de routes descendantes}\\
            RPL ne maintient pas de routes descendantes. Dans ce MOP, les DAOs ne sont pas émis par les noeuds d'un DODAG, et les noeuds ignorent les DAOs.
        \item \textbf{Non-storing mode}\\
            Dans ce mode, les DAOs sont envoyés en unicast à la racine du DODAG.
            Les noeuds ne stockent pas de routes descendantes. Donc les routes sont établies par source routing. C'est à dire que les paquets remontent jusqu'à la racine du DODAG qui place dans les paquets tous les sauts de la route pour ensuite redescendre (Fig.~\ref{fig:state-path-nonstoring}).
            %source/dest DAO unique-local ou global
        \item \textbf{Storing mode}\\
            Le storing mode peut être utilisé avec ou sans multicast.
            Dans ce mode, les DAOs sont envoyées en unicast par les noeuds à leur parent(s)
            Les paquets remontent jusqu'à un ancêtre commun avec la destination avant de redescendre vers celle-ci (Fig.~\ref{fig:state-path-storing}).
            Les noeuds stockent les routes de leur sous DODAG. Ainsi, chanque saut dans un chemin examine sa table de routage pour choisir le saut suivant.
            %source et destination des DAO: link-local
    \end{itemize}
    
    \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
            \includegraphics[scale=0.4]{res/pictures/rpl-nonstoring.drawio.png}
            \caption{Non-Storing.}
            \label{fig:state-path-nonstoring}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.45\textwidth}
            \includegraphics[scale=0.4]{res/pictures/rpl-storing.drawio.png}
            \caption{Storing.}
            \label{fig:state-path-storing}
        \end{subfigure}
        \caption{Chemin d'un paquet en fonction du MOP.}
        \label{fig:state-path-mop}
    \end{figure}

    Un noeud voulant rejoindre un DODAG doit être compatible avec le MOP du DODAG. Si ce n'est pas le cas, il doit rejoindre le DODAG comme feuille.



\subsection*{Discussion}

    D'après~\cite{paper:rpl-study}, après avoir été étudiés par le groupe de travail IETF roll (Routing Over Low power and Lossy networks (roll), il s'est avéré que les protocoles tel que OSPF, AODV ou OLSR ne satisfont pas toutes les exigences des LLNs. C'est pour cette raison que ce groupe de travail a introduit RPL.

    De plus, de part sa topologie et son fonctionnement, RPL est optimisé pour la collecte de données ce qui est l'utilisation principale pour ce mémoire.

    %todo article qui regroupe plusieurs etudes: implémentation pas idéale dans COntiki mais article de 2017 -> corrigé depuis ??


%p9: peut bind un subnet
%p17: DODAG repair